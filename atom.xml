<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>想要上树的小猪</title>
  
  <subtitle>永远年轻，永远热泪盈眶。</subtitle>
  <link href="/MichaelLiu1999.github.io/atom.xml" rel="self"/>
  
  <link href="https://MichaelLiu1999.github.io/"/>
  <updated>2019-06-11T06:31:52.406Z</updated>
  <id>https://MichaelLiu1999.github.io/</id>
  
  <author>
    <name>Leo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Faded--吉他版</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/11/music-guitar/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/11/music-guitar/</id>
    <published>2019-06-11T06:09:35.000Z</published>
    <updated>2019-06-11T06:31:52.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Faded"><a href="#Faded" class="headerlink" title="Faded"></a>Faded</h1><video id="video" controls preload="auto" height="400" width="600">    <source id="mp4" src="/images/Guitar-faded.mp4" type="video/mp4"></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Faded&quot;&gt;&lt;a href=&quot;#Faded&quot; class=&quot;headerlink&quot; title=&quot;Faded&quot;&gt;&lt;/a&gt;Faded&lt;/h1&gt;&lt;video id=&quot;video&quot; controls preload=&quot;auto&quot; height=&quot;400&quot; width=
      
    
    </summary>
    
      <category term="music" scheme="https://MichaelLiu1999.github.io/categories/music/"/>
    
    
      <category term="guitar" scheme="https://MichaelLiu1999.github.io/tags/guitar/"/>
    
  </entry>
  
  <entry>
    <title>排序算法分析</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/11/sortingAlgorithm/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/11/sortingAlgorithm/</id>
    <published>2019-06-11T04:07:14.000Z</published>
    <updated>2019-06-11T07:48:40.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><em>之前一直都是在用冒泡排序，感觉好low,索性记录下其他性能更好的排序算法。</em></p><p><strong>注：所有的排序算法都是基于非递减排序。</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>原理</li></ul><p>从整个待排序列中选出一个元素插入到已经有序的子序列中去，得到一个有序的、元素加一的子序列，直到整个序列的待插入元素为0，则整个序列全部有序。<br>在实际的算法中，我们经常选择序列的第一个元素作为有序序列（因为一个元素肯定是有序的），我们逐渐将后面的元素插入到前面的有序序列中，直到整个序列有序。</p><ul><li>Draw</li></ul><p>Sequence: 89 3 72 43 1<br>1st:    89 3 72 43 1<br>2nd:    3 89 72 43 1<br>3rd:    3 72 89 43 1<br>4th:    3 43 72 89 1<br>5th:    1 3 43 72 89</p><ul><li>Code(Java)</li></ul><p>(<code>)    public static void insertSort(int[] array)    {        int size = array.length;        int temp = 0;        int j = 0;        for(int i=0; i&lt;size; i++)        {            temp = array[i];            for(j=i; j&gt;0 &amp;&amp; temp &lt; array[j-1]; j--)            {                array[j] = array[j-1];            }            array[j] = temp;        }    }(</code>)</p><p>Time Complexity: O(n2)</p><h2 id="Divide-and-Conquer-分而治之"><a href="#Divide-and-Conquer-分而治之" class="headerlink" title="Divide and Conquer(分而治之)"></a>Divide and Conquer(分而治之)</h2><ul><li>将一个大型的问题分解成多个小的子问题，最后在用递归将所有子问题合并。</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>原理</li></ul><p>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，但最的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；</p><p>2.将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；</p><p>3.对左右两个分区重复以上步骤直到所有元素都是有序的。</p><ul><li>Draw</li></ul><p><img src="/imgaes/quickSort" alt></p><ul><li>Code(Java)</li></ul><p>(<code>)    public static void quickSort(int[] array, _left, _right)    {        int left = _left;        int right = _right;        int temp = 0;        if(left &lt;= right)        {            //分而治之            //设置一个基准(base)            temp = array[left];            while(left != right)            {                //把比基准小的元素都放到左边                while(right &gt; left &amp;&amp; array[right] &gt;= temp)                    right--;                array[left] = array[right];                //把比基准大的元素都放到右边                while(left &lt; right &amp;&amp; array[left] &lt;= temp)                    left++;                array[right] = array[left];            }            //基准归位            array[right] = temp;            //递归            quickSort(array, _left, left-1); //对基准左边的元素进行递归排序            quickSort(array,right+1, _right); //对基准左边的元素进行递归排序        }    }(</code>)</p><p>Time complexity: It depends, unstable.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;&lt;em&gt;之前一直都是在用冒泡排序，感觉好low,索性记录下其他性能更好的排序算法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="major" scheme="https://MichaelLiu1999.github.io/categories/major/"/>
    
    
      <category term="算法分析" scheme="https://MichaelLiu1999.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Induction(数学归纳法)</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/11/induction/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/11/induction/</id>
    <published>2019-06-11T02:33:00.000Z</published>
    <updated>2019-06-11T02:43:54.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p><em>勤能补拙，水滴石穿</em></p><img src="/images/bg-2.jpg" width="400" height="400" div align="center"><h2 id="数学归纳法的证明步骤"><a href="#数学归纳法的证明步骤" class="headerlink" title="数学归纳法的证明步骤"></a>数学归纳法的证明步骤</h2><ul><li><p>设n=1(0)(注意有时候是多个条件)时，等式成立</p></li><li><p>假设n=k时，等式两边也精确成立</p></li><li><p>通过等式变换，证明n=k+1时等式也精确成立</p></li><li><p>证毕</p></li></ul><p><img src="/images/induction.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h1&gt;&lt;p&gt;&lt;em&gt;勤能补拙，水滴石穿&lt;/em&gt;&lt;/p&gt;
&lt;img src=&quot;/images/bg-2.jpg&quot; width=&quot;
      
    
    </summary>
    
      <category term="major" scheme="https://MichaelLiu1999.github.io/categories/major/"/>
    
    
      <category term="算法分析" scheme="https://MichaelLiu1999.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>算法的时间复杂度分析</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/11/timeComplexity/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/11/timeComplexity/</id>
    <published>2019-06-11T01:51:01.000Z</published>
    <updated>2019-06-11T02:24:44.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度的三种表示方法"><a href="#时间复杂度的三种表示方法" class="headerlink" title="时间复杂度的三种表示方法"></a>时间复杂度的三种表示方法</h1><p><em>Ο Ω Θ表示法，in-place algorithm, pre-condition, post-condition</em></p><img src="/images/bg-1.jpg" width="400" height="400" div align="center"><h2 id="Ο-Ω-Θ表示法"><a href="#Ο-Ω-Θ表示法" class="headerlink" title="Ο Ω Θ表示法"></a>Ο Ω Θ表示法</h2><ul><li><p>大Ο表示法（上界）</p><p>  f(n) ∈ O(g(n)) if there exists constants c &gt; 0 and n0 &gt; 0,</p><pre><code>such thatf(n) ≤ c.g(n)  for all  n &gt; n0 </code></pre></li></ul><ul><li><p>大Ω表示法（下界）</p><p>  f(n) ∈ Ω(g(n)) if there exists constants c &gt; 0 and n0 &gt; 0,</p><pre><code>such that     f(n) ≥ c·g(n)  for all  n &gt; n0 </code></pre></li></ul><ul><li>大Θ表示法（确界）<br>  f(n) ∈ Θ(g(n)) if there exists constants c1 &gt; 0, c2 &gt; 0 and n0 &gt; 0, <pre><code>such that    c2·g(n) ≤ f(n) ≤ c1·g(n)  for all  n &gt; n0 </code></pre></li></ul><p><img src="/images/timeComplexity.png" alt="两个算法的时间复杂度比较"></p><hr><h2 id="in-place-algorithm"><a href="#in-place-algorithm" class="headerlink" title="in-place algorithm"></a>in-place algorithm</h2><p>如果输入数据有一个自然的形式（比如，一个数组或矩阵），则我们撇开程序和输入，<br>分析还需要多少额外的空间。如果额外空间的大小是一个于输入规模有关的常量，则这样的<br>算法称为 in place</p><hr><h2 id="pre-condition-post-condition"><a href="#pre-condition-post-condition" class="headerlink" title="pre-condition, post-condition"></a>pre-condition, post-condition</h2><ul><li><p>pre-condition<br>The pre-condition indicates what must be true before the function is called.</p></li><li><p>post-condition<br>The post-condition indicates what will be true when the function finishes its work.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间复杂度的三种表示方法&quot;&gt;&lt;a href=&quot;#时间复杂度的三种表示方法&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度的三种表示方法&quot;&gt;&lt;/a&gt;时间复杂度的三种表示方法&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Ο Ω Θ表示法，in-place algorith
      
    
    </summary>
    
      <category term="major" scheme="https://MichaelLiu1999.github.io/categories/major/"/>
    
    
      <category term="算法分析" scheme="https://MichaelLiu1999.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/10/stringAlgorithm/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/10/stringAlgorithm/</id>
    <published>2019-06-10T13:38:24.000Z</published>
    <updated>2019-06-10T14:01:58.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BF算法和KMP算法的比较"><a href="#BF算法和KMP算法的比较" class="headerlink" title="BF算法和KMP算法的比较"></a>BF算法和KMP算法的比较</h1><p><strong><em>给定一个字符串(text)和一个模式字符串(pattern)，查询text中是否存在pattern子串</em></strong></p><p>Brute-Force算法比较无脑，就是从text的第一个字符开始比较，失败就从第二个字符开始，以此类推。</p><p><a href="https://www.cnblogs.com/zxcjj/p/6529387.html" target="_blank" rel="noopener">BF算法详解</a></p><hr><p>Knuth-Morris-Pratt算法是的核心是尽可能多的把text的匹配字符往前移动，减少循环次数。总共分两个步骤：</p><ul><li>初始化一个与pattern字符串长度相同的int数组，根据pattern字符串的模式给其赋值，该值可以使每一次text的字符尽可能多的往前移动。</li><li>根据int数组开始进行字符串匹配</li></ul><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/80719203" target="_blank" rel="noopener">KMP算法详解（我觉得写的比较让人容易看懂）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BF算法和KMP算法的比较&quot;&gt;&lt;a href=&quot;#BF算法和KMP算法的比较&quot; class=&quot;headerlink&quot; title=&quot;BF算法和KMP算法的比较&quot;&gt;&lt;/a&gt;BF算法和KMP算法的比较&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;给定一个字符串(text)和
      
    
    </summary>
    
      <category term="major" scheme="https://MichaelLiu1999.github.io/categories/major/"/>
    
    
      <category term="算法分析" scheme="https://MichaelLiu1999.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java学习路线</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/10/javaLearning/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/10/javaLearning/</id>
    <published>2019-06-10T00:41:39.000Z</published>
    <updated>2019-06-10T02:16:52.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传说中的Java封神之路"><a href="#传说中的Java封神之路" class="headerlink" title="传说中的Java封神之路"></a>传说中的Java封神之路</h1><a id="more"></a><p><img src="/images/Java-1.jpg" alt></p><h2 id="Java-learning-reference"><a href="#Java-learning-reference" class="headerlink" title="Java learning reference"></a>Java learning reference</h2><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">github上的Java学习注解</a></p><p><strong>不定期更新</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;传说中的Java封神之路&quot;&gt;&lt;a href=&quot;#传说中的Java封神之路&quot; class=&quot;headerlink&quot; title=&quot;传说中的Java封神之路&quot;&gt;&lt;/a&gt;传说中的Java封神之路&lt;/h1&gt;
    
    </summary>
    
      <category term="java" scheme="https://MichaelLiu1999.github.io/categories/java/"/>
    
    
      <category term="学习" scheme="https://MichaelLiu1999.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>歌单--粤语</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/09/playList-1/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/09/playList-1/</id>
    <published>2019-06-09T05:05:11.000Z</published>
    <updated>2019-06-09T06:24:44.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20岁听过的粤语歌"><a href="#20岁听过的粤语歌" class="headerlink" title="20岁听过的粤语歌"></a>20岁听过的粤语歌</h1><p>有那么一首歌可以唱到你心坎里。</p><a id="more"></a><ul><li>陈奕迅–人来人往</li><li>陈奕迅–十面埋伏</li><li>陈奕迅–落花流水</li><li>谢安琪–钟无艳</li><li>谢安琪–喜帖街</li><li>陈奕迅–Lonely Christmas</li><li>陈小春–我不是伟人</li><li>梁汉文–七友</li><li>陈奕迅–倾城</li><li>李克勤–红日</li><li>Beyond–光辉岁月</li><li>Beyond–海阔天空</li><li>Beyond–真的爱你</li><li>陈奕迅–浮夸</li><li>陈奕迅–岁月如歌</li><li>陈奕迅–单车</li><li>陈奕迅–最佳损友</li><li>陈奕迅–明年今日</li><li>陈奕迅–苦瓜</li><li>陈奕迅–富士山下</li><li>古巨基–爱得太迟</li><li>张敬轩–春秋</li><li>杨千嬅–少女的祈祷</li><li>杨千嬅–小城大事</li></ul><p><strong><em>不定期更新</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;20岁听过的粤语歌&quot;&gt;&lt;a href=&quot;#20岁听过的粤语歌&quot; class=&quot;headerlink&quot; title=&quot;20岁听过的粤语歌&quot;&gt;&lt;/a&gt;20岁听过的粤语歌&lt;/h1&gt;&lt;p&gt;有那么一首歌可以唱到你心坎里。&lt;/p&gt;
    
    </summary>
    
      <category term="music" scheme="https://MichaelLiu1999.github.io/categories/music/"/>
    
    
      <category term="歌单" scheme="https://MichaelLiu1999.github.io/tags/%E6%AD%8C%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>老照片--我的城市</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/09/Photo-myCity/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/09/Photo-myCity/</id>
    <published>2019-06-09T04:02:09.000Z</published>
    <updated>2019-06-09T06:24:47.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故乡"><a href="#故乡" class="headerlink" title="故乡"></a>故乡</h1><p>小时候生活的港湾。</p><a id="more"></a><p><img src="/images/myTown-1.jpg" alt></p><p><img src="/images/myTown-2.jpg" alt></p><p><img src="/images/myTown-3.jpg" alt></p><p><img src="/images/myTown-4.jpg" alt></p><p><img src="/images/myTown-5.jpg" alt></p><p><img src="/images/myTown-6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;故乡&quot;&gt;&lt;a href=&quot;#故乡&quot; class=&quot;headerlink&quot; title=&quot;故乡&quot;&gt;&lt;/a&gt;故乡&lt;/h1&gt;&lt;p&gt;小时候生活的港湾。&lt;/p&gt;
    
    </summary>
    
      <category term="photo" scheme="https://MichaelLiu1999.github.io/categories/photo/"/>
    
    
      <category term="随手拍" scheme="https://MichaelLiu1999.github.io/tags/%E9%9A%8F%E6%89%8B%E6%8B%8D/"/>
    
  </entry>
  
  <entry>
    <title>札记--偶尔迷茫，偶尔挣扎</title>
    <link href="https://MichaelLiu1999.github.io/2019/06/09/Article--1st/"/>
    <id>https://MichaelLiu1999.github.io/2019/06/09/Article--1st/</id>
    <published>2019-06-09T01:58:21.000Z</published>
    <updated>2019-06-10T08:54:15.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="偶尔迷茫，偶尔挣扎"><a href="#偶尔迷茫，偶尔挣扎" class="headerlink" title="偶尔迷茫，偶尔挣扎"></a>偶尔迷茫，偶尔挣扎</h1><p>知乎专栏写的第一篇文章，留作纪念。</p><p><img src="/images/myLove.png" alt></p><p>偶尔想在无聊的时候写写东西，仅此而已。</p><p>总是想想自己怎么能够写出一些有思想深度的的见解，但是也真没什么可说的。可能是真的很久很久都没有静下心来写一些东西的缘故吧。理科生一枚，心里却还是充满着随性和感性，偶尔迷茫，不知所措；偶尔挣扎，觉得自己不该甘于平庸。</p><p>大一刚入学的时候，满满地都是对高中逝去的不舍与留恋，以及对大学的憧憬和期许。可能正如《围城》所述“城外面的人想进来，城里面的人想出去。”圈子里的很多人经常在原地打转，出了这个圈子，才唏嘘“当时我怎么怎么样就好了”。于是我们的一生就是不断地从一个圈子里面出来，再往另一个圈子里走，遗憾和缺失总是相伴我们左右。有时我总会想想这可能是自我逃避的一种表现，因为那些所谓的美好和缺憾大多是需要我们勇敢去捍卫，去争取，多说也只是虚妄。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;偶尔迷茫，偶尔挣扎&quot;&gt;&lt;a href=&quot;#偶尔迷茫，偶尔挣扎&quot; class=&quot;headerlink&quot; title=&quot;偶尔迷茫，偶尔挣扎&quot;&gt;&lt;/a&gt;偶尔迷茫，偶尔挣扎&lt;/h1&gt;&lt;p&gt;知乎专栏写的第一篇文章，留作纪念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images
      
    
    </summary>
    
      <category term="article" scheme="https://MichaelLiu1999.github.io/categories/article/"/>
    
    
      <category term="知乎" scheme="https://MichaelLiu1999.github.io/tags/%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
</feed>
